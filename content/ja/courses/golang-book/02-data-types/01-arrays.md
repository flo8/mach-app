---
title: 配列
description: ここでは、配列について学び、配列の構築方法、アイテムへのアクセス、繰り返し処理について学びます。
lastmod: 2023-05-26T02:57:04.860Z
---

# 配列とスライス

この章では、配列とスライスについて説明します。

## はじめに

この章では以下の内容をカバーします：

- 配列の宣言と検査
- 配列内の要素へのアクセス
- スライスの操作

## 配列

配列は、連結された要素のグループです。何かのグループ（例：注文、車、ファイル内の行など）がある場合には、配列を使用する必要があります。

配列のアイデアは、すべてのデータを1つの構造体にまとめることです。また、それを繰り返し処理してグループとして操作することもできるようにしたいです。

## 配列の宣言

配列を宣言するには、次のプロパティを指定する必要があります：

- **容量**：配列が保持できる要素の数。
- **型**：配列が保持する要素の型。
- **配列の内容**：作成時に要素を割り当てるか、後から割り当てるかを指定できます。

以下は構文です：

```go
[<容量>]<型>{...要素}
```

これは、角括弧 `[]` で始まります。角括弧内で容量を設定し、保持できる要素の数を指定します。

以下は実際の例です：

```go
cities := [5]string{"NY", "LA"}
```

上記のコードでは、文字列の配列が宣言されています。容量は5つの要素を保持できるように設定されており、2つの場所には "NY" と "LA" が入っています。また、容量を5に設定し、割り当てられた要素の数が2であるため、3つの空きスペースがあります。

### 推論による容量の設定

容量を明示的な数値に設定する必要はありません。`...` と設定することで、要素に割り当てる数に基づいて容量が設定されます。以下のようになります：

```go
ids := [...]int{1, 2, 3, 4}
```

上記のコードは4つの要素を持ち、それが容量でもあります。

## 要素へのアクセス

要素にアクセスする方法は、インデックスを使用することです。インデックスは0から始まり、最初のインデックスは0であり、最後のインデックスは長さ-1です。

```go
ids := [...]int{1, 2, 3, 4}
ids[0] // 1
ids[3] // 4
```

## 長さと容量

次のような配列が宣言されていると想像してください：

```go
cities := [5]string{"NY", "LA"}
```

- **長さ**：長さは配列内の要素の数と定義されます。`len()` メソッドを使用して長さを取得できます：

  ```go
  len(cities) // 2
  ```

- **容量**：容量は配列が保持できる要素の数です。容量を取得するには `cap()` メソッドを使用します：

  ```go
  cap(cities) // 5
  ```

## スライス

スライスは配列の一部です。スライスは、スライス演算子が使用されると作成されます。スライス演算子の構文は次のとおりです：

```go
s[i:p]
```

- `s`：配列
- `i`：スライスの最初のインデックス
- `p`：新しいスライスで使用される基になる配列の最後の要素に対応する変数 p。つまり、このインデックスの直前で切り取ります。

```go
items := [5]int{1,2,3,4,5}
part = items[1:3] // 2,3
```

### 要素の追加

スライスは配列と異なり、要素を追加できます。`append()` メソッドを使用すると要素を追加できます。`append()` の構文は次のとおりです：

```go
append(スライス, 要素)
```

以下はスライスへの追加方法です：

```go
var numbers []int
numbers = append(numbers, 1)
numbers = append(numbers, 2) // 1,2
```

### 要素の削除

新しいスライスを構築することで要素を削除します。

```go
letters := []string{"A", "B", "C", "D", "E"}
remove := 2 // 削除するインデックス
// 0 - 削除するインデックス、削除 +1 から末尾まで
letters = append(letters[:remove], letters[remove+1:]...)
// [A B D E]
```

### `make()` を使用したスライスの作成

`make()` メソッドを使用してスライスを作成できます。以下の方法で作成します：

```go
slice := make([]int, 5) // 長さ5、容量5のスライスを作成
```

これらを異なる値に設定することもできます：

```go
slice2 := make([]int, 2, 5)
fmt.Println(slice2)
fmt.Println(len(slice2))
fmt.Println(cap(slice2))
```

ここでは、スライスの長さは2で、容量は5です。

### 要素のコピー

```go
arr := [3]int{1, 2, 3}
dest := make([]int, 5)
copy(dest, arr[0:2]) // スライス {1,2} を dest にコピー
fmt.Println(dest) // [1 2 0 0 0]
```

## 課題 - ログエントリの保存

ログエントリ用の配列を作成します。次のように使用できます：

```console
command> new
新しいエントリです
command> new
別のエントリです
command> list
新しいエントリです
別のエントリです
command> quit
さようなら
```

したがって、複数の文字列を保存し、要求された場合にリスト表示する方法が必要です。

以下は、コンソール入力を処理するためのスターターコードです：

```go
package main

import (
 "fmt"
)

func main() {
 // 配列を作成

 var response string
 for {
  fmt.Print("command> ")
  fmt.Scan(&response)
  if response == "quit" {
   break
  } else if response == "new" {
   fmt.Print("Entry:")
   fmt.Scan(&response)
   // エントリをリストに保存
   fmt.Println("エントリを保存中")
  } else if response == "list" {
   // エントリをリスト表示
   fmt.Println("エントリをリスト表示中")
  } else {
   fmt.Println("不明なコマンド", response)
  }

 }
 fmt.Println("さようなら")
}
```

コメントのある場所に独自のコードを追加してください。

## 解答例

```go
package main

import (
 "fmt"
)

func main() {
 // 配列を作成
 arr := make([]string, 0)

 var response string
 for {
  fmt.Print("command> ")
  fmt.Scan(&response)
  if response == "quit" {
   break
  } else if response == "new" {
   fmt.Print("Entry:")
   fmt.Scan(&response)

   // エントリをリストに保存
   arr = append(arr, response)
   fmt.Println("エントリを保存中")
  } else if response == "list" {
   // エントリをリスト表示
   fmt.Println("エントリをリスト表示中")
   for i := 0; i < len(arr); i++ {
    fmt.Println(arr[i])
   }
  } else {
   fmt.Println("不明なコマンド", response)
  }

 }
 fmt.Println("さようなら")
}
```
